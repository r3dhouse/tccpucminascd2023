# -*- coding: utf-8 -*-
"""base_proc_tratam.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18M2kchxuvUjJOUWGaLbBLRmY9SpyXAPR

# 1) Preparação do Ambiente

## 1.1) Importação das Bibliotecas
"""

# coding=utf-8

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

from google.colab import files

pd.set_option('display.precision', 2)
pd.set_option('display.max_columns', 500)
pd.set_option('display.width', 1000)
pd.options.display.float_format = '{:,.2f}'.format

!python --version
!pip list

"""## 1.2) Carga da Base (Arquivo Excel)

Base contém os dados conjuntos de Arrecadação, PIB e Inadimplência.

Carga do arquivo base_consolidada.xlsx para DataFrame base.
"""

arq_base = files.upload()
colunas = 'B:N'

base = pd.read_excel(arq_base['base_consolidada.xlsx'], usecols=colunas)

"""## 1.3) Estatística Descritiva dos Dados

*   Campos;
*   Tipos dos campos;
*   Atributos categóricos;
*   Descrição dos dados;
"""

print('*' * 73)
print('Campos da Base Consolidada com dados de Inadimplência, Arrecadação e PIB:')
print('*' * 73)
print('-' * 31)
print('Colunas          Tipo dos dados')
print('-' * 31)
print(base.dtypes)
print('-' * 37)
print('Atributos Categóricos:')
print('-' * 37)
atributos_categoricos = base.dtypes[base.dtypes == 'object'].index
print(base[atributos_categoricos].describe(), sep='\n')
print('*' * 172)
print('Descrição dos dados:')
print('-' * 172)
print(base.describe())
print('-' * 172)

"""# -----------------------------------------------------------------------------------------------------------

# 2) Ajuste e Transformação da Base

## 2.1) Eliminação dos Municípios com Inadimplência maior que 0,99.

Após análise dos dados e da realidade dos demais 5567 municípios, por definição, não se pode ter MEIs não pagantes no ano maior do que o seu total, ou seja, inadimplência maior do que 1 não é possível.

Serão mantidos todos apresentam inadimplência abaixo de 0,99.

Uma possível assunção seria a troca dos dados nas colunas DAS Pagos e Optantes do Simples - MEI.
"""

print('*' * 71)
print('Municípios com Inadimplência maior que 0,99:')
print('-' * 71)
outliers_inad = pd.DataFrame
outliers_inad = base.loc[(base['inad_2020'] >= 1)]
print(outliers_inad.iloc[:, 0:5])
for indice in (base.loc[(base['inad_2020'] >= 1)]).index:
    base.drop(indice, inplace=True)
base.reset_index(drop=True, inplace=True)
print('*' * 71)
print('-' * 87)
print('Descrição dos dados, após eliminação 3 dos Municípios com Inadimplência maior que 0,99:')
print('-' * 172)
print(base.describe())
print('-' * 172)
print('Registros: ', base.shape[0], 'Colunas: ', base.shape[1])
print('*' * 29)

print(base.iloc[[4061,1925,1252,3019,5130]])

"""## 2.2) One-Hot-Enconding para a Sigla dos Estados
Utilidade da diferenciação regional nas análises.
"""

siglas = pd.get_dummies(base.Sigla, prefix='Est')
base_processamento = pd.DataFrame()
base_processamento = pd.concat([base,siglas],axis=1)
base_processamento.drop(columns=['Sigla', 'Estado', 'Municipio'], inplace=True)
print('*' * 62)
print('Colunas da base_processamento - aplicação do One_Hot_Enconding')
print('-' * 62)
print(base_processamento.dtypes)
print('*' * 62)

print('*' * 174)
print('Base Consolidada Original:')
print('-' * 174)
print(base)
print('*' * 357)
print('Base após processamento de one-hot-enconding para os Estados:')
print('-' * 61)
print(base_processamento)

"""## 2.3) Transformando as variáveis float64 para base log10"""

colunas_float = base_processamento.dtypes[base_processamento.dtypes == 'float64'].index
colunas_float = colunas_float.drop(['inad_2020'])

base_process_log10 = pd.DataFrame
base_process_log10 = base_processamento.copy()

for coluna in colunas_float:
    base_process_log10[coluna] = base_process_log10[coluna].apply(lambda x: np.log10(abs(x)) if x!= 0 else -10).astype(float)

print('*' * 370)
print('Base após Transformação para base em log10 da variáveis float64:')
print('-' * 64)
print(base_process_log10.describe())
print('*' * 370)

"""# -----------------------------------------------------------------------------------------------------------

# 3) Análise dos Dados

## 3.1) Estatísticas descritivas da base_process_log10
"""

print('*' * 78)
print('Campos da Base de Processamento com dados de Inadimplência, Arrecadação e PIB:')
print('*' * 78)
print('-' * 31)
print('Colunas          Tipo dos dados')
print('-' * 31)
print(base_process_log10.dtypes)
print('*' * 31)

print('*' * 415)
print('Base origem antes da transformação:')
print('-' * 35)
print(base_processamento.describe())
print('*' * 415)
print('Base após Transformação para base em log10 da variáveis float64:')
print('-' * 64)
print(base_process_log10.describe())
print('*' * 370)

"""## 3.2) Histogramas das colunas dos dados originais"""

def plota_histogramas (dados):
    colunas = list(dados.keys())
    atrib_categ = list(dados.dtypes[dados.dtypes != 'float64'].index)
    for coluna in colunas:
        if not coluna in atrib_categ:
            dados.hist(column=coluna, figsize=(9,6), bins=5)


plota_histogramas(base_processamento)

"""## 3.3) Histogramas das colunas dos dados após transformação para escala logaritmica base 10"""

plota_histogramas(base_process_log10)

"""## 3.4) Detectando Outliers

Outliers são valores que distoam da média dos valores constantes de uma série ou conjunto de dados.

"""

def plota_box (dados, coluna, municip, qtd):
    dados.boxplot(column=coluna, figsize=(9,9))
    if municip:
        maiores = dados.nlargest(qtd, coluna)
        maiores.reset_index(drop=False, inplace=True)
        maiores_filtro = maiores[['Sigla', 'Municipio', coluna]]
        print('Maiores')
        print(maiores_filtro)
        menores = dados.nsmallest(qtd, coluna)
        menores.reset_index(drop=False, inplace=True)
        menores_filtro = menores[['Sigla', 'Municipio', coluna]]
        print('Menores')
        print(menores_filtro)
    print(dados[coluna].describe())

# Gráfico boxplot da Arrecadação de 2020 - Base original
plota_box (base, 'arrec_2020', True, 27)

# Gráfico boxplot da Arrecadação de 2020 - Base Logaritmíca
plota_box (base_process_log10, 'arrec_2020', False, 27)

"""Função para listar os Municípios acima do índice de Inadimplência fornecido."""

def lista_inadimplentes(base_inad, indice):
    inadimplencia = base_inad.loc[base_inad['inad_2020'] >= indice]
    print('*' * 60)
    print('Índice Percentual de Inadimplência maior que: ', indice)
    print('-' * 60)
    print('Estados   : ', inadimplencia['Sigla'].nunique())
    print('Municípios: ', inadimplencia.shape[0])
    print('-' * 30)
    inad_filtro = inadimplencia[['Estado','Sigla', 'Municipio', 'inad_2020']]
    print(inad_filtro.groupby('Estado')['Municipio'].nunique())
    print('*' * 60)
    arq_inad = 'ind_inad_' + str(indice) + '.xlsx'
    inad_filtro.to_excel(arq_inad)
    files.download(arq_inad)

# Gráfico boxplot da Inadimplência de 2020 - Base Original
plota_box (base, 'inad_2020', True, 27)

# Apresenta Estados com Índices de Inadimplência parametrizado (Maior que)
lista_inadimplentes(base, 0.75)
lista_inadimplentes(base, 0.57)

# Gráfico boxplot da Valor Agregado do Agro do IBGE de 2020 - Base Original
plota_box (base, 'Valor_ab_agro', True, 27)

# Gráfico boxplot da Valor Agregado do Agro do IBGE de 2020 - Base Logarítmica
plota_box (base_process_log10, 'Valor_ab_agro', False, 1)

# Gráfico boxplot da Valor Agregado da Indústria do IBGE de 2020 - Base Original
plota_box (base, 'Valor_ab_indu', True, 27)

print(base.loc[base['Valor_ab_indu'] >= 5000000000])

# Gráfico boxplot da Valor Agregado da Indústria do IBGE de 2020 - Base Logarítmica
plota_box (base_process_log10, 'Valor_ab_indu', False, 1)

# Gráfico boxplot da Valor Agregado dos Serviços do IBGE de 2020 - Base Original
plota_box (base, 'Valor_ab_serv', True, 27)

# Gráfico boxplot da Valor Agregado dos Serviços do IBGE de 2020 - Base Logarítmica
plota_box (base_process_log10, 'Valor_ab_serv', False, 1)

# Gráfico boxplot da Valor Agregado de Serviços Públicos do IBGE de 2020 - Base Original
plota_box (base, 'Valor_ab_publ', True, 27)

# Gráfico boxplot da Valor Agregado de Serviços Públicos do IBGE de 2020 - Base Logarítmica
plota_box (base_process_log10, 'Valor_ab_publ', False, 1)

# Gráfico boxplot da Valor Agregado do IBGE de 2020 - Base Original
plota_box (base, 'Valor_abt', True, 27)

# Gráfico boxplot da Valor Agregado do IBGE de 2020 - Base Logarítmica
plota_box (base_process_log10, 'Valor_abt', False, 1)

# Gráfico boxplot dos Impostos da base do PIB do IBGE de 2020 - Base Original
plota_box (base, 'Impostos', True, 27)

# Gráfico boxplot dos Impostos da base do PIB do IBGE de 2020 - Base Logarítmica
plota_box (base_process_log10, 'Impostos', False, 1)

# Gráfico boxplot do PIB do IBGE de 2020 - Base Original
plota_box (base, 'PIB', True, 27)

# Gráfico boxplot do PIB do IBGE de 2020 - Base Logarítmica
plota_box (base_process_log10, 'PIB', False, 1)

# Gráfico boxplot da PIB per capita do IBGE de 2020 - Base Original
plota_box (base, 'PIB_pc', True, 27)

# Gráfico boxplot da PIB per capita do IBGE de 2020 - Base Logarítmica
plota_box (base_process_log10, 'PIB_pc', False, 1)

"""# -----------------------------------*********************************************----------------------------------****--------------------------------------
# 4) Correlação

## 4.1) Scater Plot

Matriz de dispersão da base em escala logatítmica base 10
"""

col_flt = list(base_process_log10.dtypes[base_process_log10.dtypes == 'float64'].index)
sns.pairplot(base_process_log10[col_flt], corner=True)

"""Matriz de dispersão da base com dados em seus valores originais"""

col_flt_bp = list(base_processamento.dtypes[base_processamento.dtypes == 'float64'].index)
sns.pairplot(base_processamento[col_flt_bp], corner=True)

"""## 4.2) Detecção do Coeficiente de Correlação de Pearson entre as variáveis e o Label."""

campos = base_process_log10.dtypes[base_process_log10.dtypes != 'object'].index
base_correlacao = np.corrcoef(base_process_log10[campos].transpose())
correlacao = pd.DataFrame(data=base_correlacao, index=campos, columns=campos)

# Baixas correlações com o Label - inad_2020
correl_label = pd.DataFrame()
correl_label = correlacao['inad_2020'].abs().sort_values(ascending=False)
print('*' * 65)
print('Correlação entre o Label e demais variáveis da base_process_log10')
print('*' * 65)
print(correl_label)

# Filtro das colunas float64
col_flt = list(base_process_log10.dtypes[base_process_log10.dtypes == 'float64'].index)

# Criando máscara
mascara = np.triu(np.ones_like(base_process_log10[col_flt].corr(), dtype=bool))
np.fill_diagonal(mascara, False)

# Parâmetros para criação do palette
cmap = sns.diverging_palette(100, 7, s=75, l=40, n=5, center="light", as_cmap=True)

# Tamanho do mapa de calor e criação do mesmo
plt.figure(figsize=(10, 6))
sns.heatmap(base_process_log10[col_flt].corr(), mask=mascara, center=0, annot=True, fmt='.2f', square=True, cmap=cmap)

# Apresenta o het map só com o triângulo inferior da matriz definida pela mascara e palette
plt.show()

# nova coluna indice para preparação da tabela pivot e cria tabela pivot
correlacao ['ind_pivot'] = correlacao.index
corr_pivot = correlacao.melt(id_vars='ind_pivot').copy()

# Filtro para correlaçãoes maiores que 0.93
aux_corr_pivot = corr_pivot[abs(corr_pivot['value']>0.93)].sort_values('ind_pivot')
print('*' * 62)
print('Correlação entre variáveis preditoras acima de 0,93 (absoluto)')
print('*' * 62)
print(aux_corr_pivot[aux_corr_pivot['ind_pivot'] != aux_corr_pivot['variable']])

"""## 4.3) Eliminação de atributos:

*   Baixa Colinearidade com o Label

                        Est_GO



*   Alta Colinearidade entre atributos (Exceto Label)

                       Valor_ab_indu

                       Valor_ab_serv

                       Valor_abt

                       Impostos




"""

base_process_log10.drop(columns=['Est_GO','Valor_ab_indu', 'Valor_ab_serv', 'Valor_abt','Impostos'], inplace=True)
print('*' * 281)
print('Base Final para aplicação dos Modelos de Machine Learning')
print('-' * 75)
print(base_process_log10)
print('*' * 281)

"""## 4.4) Gravação da base final em formato Excel"""

base_process_log10.to_excel('base_final_ml.xlsx')
files.download('base_final_ml.xlsx')